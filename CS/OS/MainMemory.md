# 메모리

#### 메인 메모리

CPU가 직접 접근할 수 있는 기억 장치

프로세스가 실행되려면 프로그램이 메모리에 올라와야 함!

메인 메모리는 `주소가 할당된 일련의 바이트`들로 구성됨



CPU는 레지스터가 지시하는 대로 메모리에 접근해서 다음 수행 명령어 가져옴

명령어 수행 시 메모리에 필요한 데이터 없으면 해당 데이터를 우선 가져와야 함 => `MMU`가 함

#### MMU

논리 주소 => 물리 주소 변환

메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어

메모리 공간이 한정적이라서 더 많은 메모리 제공하기 위해 `가상 주소` 개념이 도입 (프로그램 상에서 사용자가 보는 주소 공간)

이 가상 주소에서 실제 데이터가 담긴 곳에 접근하기 위해서는 빠른 주소 변환이 필요함, MMU가 이것을 도움

메인 메모리에 직접 접근은 비효율적이므로 CPU와 메인 메모리 속도를 맞추기 위해 캐시 존재

##### 메모리 보호

프로세스는 독립적인 메모리 공간 가져야 하고 자기 공간만 접근할 수 있어야 함

한 프로세스에게 합법적인 주소 영역을 설정하고 잘못된 접근이 오면 `trap`을 발생시켜서 보호

<img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/BaseLimit.jpg" width="500px">

프로세스의 접근 가능한 합법적인 메모리 영역(x) `base <= x < base+limit`

해당 영역 밖에서 접근 요청하면 `trap` 발생시킴

안전성을 위해 `base`와 `limit`레지스터는 커널 모드에서만 수정 가능하도록 설계 (사용자 모드X)

#### Over Allocating

실제 메모리 사이즈보다 더 큰 사이즈 메모리를 프로세스에 할당한 상황

페이징 기법과 같은 메모리 기법은 사용자가 눈치 채지 못하도록 눈속임 통해 메모리 할당 (가상 메모리)

**과할당 상황**

1. 프로세스 실행 중 페이지 폴트 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리 빈 프레임에 페이지 올려야 하는데, 모든 메모리가 사용 중이라 빈 프레임 없음

**빈 프레임을 확보해야 한다!**

1. 메모리에 올라온 한 프로세스를 종료시켜서 빈 프레임 얻음
2. **프로세스 하나를 `swap out`하고 이 공간을 빈 프레임으로 활용**

`swapping`을 통해 공간 바꿔치기하는 2번과 달리 1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높아서 하면 안됨

#### 페이지 교체

메모리 과할당 됐을 때, 프로세스 하나를 `swap out`해서 빈 프레임을 확보하는 것

1. 프로세스 실행 도중 페이지 부재 발생

2. 페이지 폴트 발생시킨 페이지 위치를 디스크에서 찾음

3. 메모리에 빈 프레임 있는지 확인

   빈 프레임 있으면 => 해당 프레임 사용

   빈 프레임 없으면 => victim 프레임 선정해서 디스크에 기록, 페이지 테이블 업뎃

4. 빈 프레임에 페이지 폴트 발생한 페이지 올리고, 페이지 테이블 업뎃

페이지 교체 이루어지면 프로세스를 계속 수행시켜서 사용자가 알지 못하도록 해야 함

페이지 교체 당시 오버헤드를 최대한 줄여야 함

**오버헤드 감소시키기**

빈 프레임 없을 때 `victim 프레임 비울 때`와 `원하는 페이지를 프레임으로 올릴 때` 디스크 접근 이루어짐

페이지 교체 많이 이루어지면 입출력 연산이 많아져서 오버헤드 문제 생김

1. 변경비트를 모든 페이지마다 둬서, victim 페이지 정해지면 해당 페이지 비트 확인

   `set`상태 => 해당 페이지 내용이 디스크 상의 페이지 내용과 달라졌다는 뜻(페이지가 메모리 올라온 후 한 번이라도 수정 일어난 것, 디스크에 기록해야 함)

   `clear`상태 => 디스크 상 페이지 내용과 메모리 상 페이지 정보 일치 (기록할 필요 없음)

2. 페이지 교체 알고리즘을 상황에 맞게 잘 선택

   `FIFO` `LRU` `OPT`
