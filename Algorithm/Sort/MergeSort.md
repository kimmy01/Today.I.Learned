# MergeSort

- 오름차순 정렬
- 폰 노이만이 제안한 방법
- 일반적인 방법으로 구현했을 때 **안정 정렬**에 속하며, **분할 정봅 알고리즘의 한 가지**
    - 분할 정복
        - 문제를 작은 2개의 문제로 분리하고 각각 해결한 다음, 그 결과를 모아서 원래 문제를 해결하는 전략
        - 분할 정복 방법은 대개 순환 호출을 이용해서 구현
- 합병 정렬 과정
    - 리스트 길이가 0 도는 1이면 이미 정렬된 것으로 봄
    - 정렬되지 않은 리스트를 절반으로 잘라서 비슷한 크기의 2개의 부분 리스트로 나눔
    - 각 부분 리스트를 재귀적으로 합병 리스트를 이용해 정렬
    - 2개의 부분 리스트를 다시 하나의 정렬된 리스트로 합병

### 구체적인 개념

- 하나의 리스트를 2개의 균등한 크기로 분할하고, 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합해서 전체가 정렬된 리스트가 되게 하는 방법
- 합병 정렬의 3가지 단계
    - **분할** : 입력 배열을 같은 크기의 2개 부분 배열로 분할
    - **정복** : 부분 배열 정렬. 부분 배열의 크기가 충분히 작지 않으면 **순환 호출**을 이용해서 다시 분할 정복 방법 적용
    - **결합** : 정렬된 부분 배열들을 하나의 배열에 병합
- 합병 정렬 과정
    - 추가 리스트가 필요
    - 각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출해서 적용
    - 합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스틀 **합병**하는 단계

<img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/MergeSort1.jpg">

- 배열에 27, 10, 12, 20, 25, 13, 15, 22가 저장되어 있다고 가정하고 자료를 오름차순 정렬
- 2개의 정렬된 리스트를 합병하는 과정
    - 2개의 리스트의 값들을 처음부터 하나씩 비교해서 두 개의 리스트 값 중 더 작은 값을 새로운 리스트로 옮김
    - 둘 중에서 하나가 끝날 때까지 이 과정 되풀이
    - 만약 둘 중 하나의 리스트가 먼저 끝나면 나머지 리스트의 값들을 전부 새로운 리스트로 복사
    - 새로운 리스트를 원래의 리스트로 옮김

### 합병 정렬의 장점

- 안정적인 정렬 방법
    - 데이터 분포에 영향을 덜 받음
    - 입력 데이터가 무엇인든 정렬 시간 동일함
- 만약 레코드를 연결 리스트로 구현하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아짐
    - 제자리 정렬O
- 크기가 큰 레코드를 정렬할 경우 연결 리스트 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적

### 합병 정렬의 단점

- 만약 레코드를 배열로 구성하면, 임시 배열이 필요함
    - 제자리 정렬X
- 레코드들의 크기가 큰 경우, 이동 횟수가 많아서 매우 큰 시간적 낭비 초래

### 합병 정렬의 시간 복잡도

- 분할 단계
    - 비교 연산, 이동 연산 없음
- 합병 단계
    - 비교 횟수
        - 순환 호출의 길이(합병 단계 수)
            - 레코드 개수 n이 2의 거듭제곱이라고 가정, n = 2^3일 때,  2^3 → 2^2 → 2^1 → 2^0 순으로 ㅈ루어들어서 순환 호출의 깊이가 3임을 알 수 있음
                
                ⇒ **n=2^k 일때, k(k=log2n)**
                
        - 각 합병 단계의 비교 연산
            - 크기 1인 부분 배열 2개를 합병하는데 최대 2번의 비교 연산이 필요하고, 부분 배열의 쌍이 4개이므로, 2*4 = 8번의 비교 연산 필요
            - 다음 단계에서 크기 2인 부분 배열 2개를 합병하는데 최대 4번의 비교 연산이 필요하고, 부분 배열의 쌍이 2개이므로 4*2 = 8번의 비교 연산 필요
            - 마지막 단계에서는 크기 4인 부분 배열2개를 합병하는데 최대 8번의 비교 연산이 필요하고, 부분 배열의 쌍이 1개이므로 8*1 = 8 번의 비교 연산 필요
            - 이것을 일반화하면 하나의 합병 단계에서는 최대 n번의 비교 연산을 수행함을 알 수 있음
                
                ⇒ **n번**
                
    - 이동 횟수
        - 순환 호출의 깊이 (합병 단계 수)
            
            ⇒ **k = log2n**
            
        - 각 합병 단계의 이동 연산
            - 임시 배열에 복사했다가 다시 가져와야 하므로, 이동 연산은 총 부분 배열에 들어 있는 임시 요소의 개수가 n인 경우, 레코드의 이동이 2n번 발생
        - 순환 호출 깊이만큼 **합병 단계 * 각 합병 단계의 이동 연산 = 2nlog2n**

T(n) = nlog2n(비교) + 2nlog2n(이동) = 3nlog2n = **O(nlog2n)**
