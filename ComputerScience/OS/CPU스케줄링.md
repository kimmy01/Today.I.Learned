# CPU 스케줄링

#### 스케줄링

CPU를 효율적으로 사용하기 위해 프로세스를 배정하는 방법

오버헤드는 낮추고, 사용률은 높이고, 기아 현상은 낮추고

1. `Batch System` 가능하면 많은 일 수행, 시간보다는 처리량이 중요
2. `Interactive System` 빠른 응답 시간, 적은 대기 시간
3. `Real-time System` 데드라인 맞추기

#### 선점 스케줄링

OS가 CPU의 사용권을 선점할 수 있는 경우에 강제 회수함(처리시간 예측 어려움)

`I/O` `Event wait`

#### 비선점 스케줄링

프로세스 종료 or I/O 등 이벤트가 있을 때까지 실행 보장(처리시간 예측 용이함)

`Interrupt` `Schedular Dispatch`

#### 프로세스 상태
![프로세스 상태](https://github.com/kimmy01/Today.I.Learned/blob/main/images/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C.jpg)

#### CPU 스케줄링 종류

* 비선점

  * **FSFS**(First Come First Served)
    * 큐에 도착한 순서대로 CPU할당
    * 실행시간 짧은 게 뒤로 가면 평균 대기 시간 길어짐
  * **SJF**(Shortest Job First)
    * 수행시간이 제일 짧다고 판단되는 작업 먼저 수행
    * FCFS보다 평균 대기 시간 감소, 짧은 작업에 유리
  * **HRN**(Highest Response-ration Next)
    * 우선순위 계산해서 점유 불평등 보완
    * 우선순위 = (대기시간 + 실행시간) / 실행시간

* 선점

  * **우선순위 큐**
    * 정적/동적으로 우선순위 부여해서 우선순위가 높은 순서대로 처리
    * 우선순위가 낮은 프로세스가 무한정 기다리는 **기아현상**이 생길 수 있음
    * **Aging** 방법으로 기아현상 해결 가능
  * **라운드 로빈**
    * FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 **Time Quantum(할당 시간)**만큼 CPU 할당 받음
    * **Time Quantum** : 실행의 최소 단위 시간
    * 할당 시간이 크면 FCFS와 같게 되고, 작으면 Context Switching이 잦아져서 오버헤드 증가

* 다단계 큐
  <img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/%EB%8B%A4%EB%8B%A8%EA%B3%84%ED%81%90.jpg" width="400px">
  * 작업들을 여러 종류의 그룹으로 나눠 여러 개의 큐를 이용하는 기법
  * 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 할당 시간을 설정해 주는 방식 사용
  * 우선순위가 높은 큐는 **작은 할당 시간**, 우선순위가 낮은 큐는 **큰 할당 시간** 

* 다단계 피드백 큐

  * 다단계 큐에서 자신의 할당 시간을 다 채운 프로세스는 밑으로 내려가고 자신의 할당 시간을 다 못채운 프로세스는 원래 큐 그대로 둠.
  * 할당 시간 다 채운 프로세스는 CPU  burst 프로세스로 판단하기 때문
  * 짧은 작업에 유리, 입출력 위주(인터럽트 잦은) 작업에 우선권을 줌
  * 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

  

#### CPU 스케줄링 척도

1. **Response Time**

   작업이 처음 실행되기까지 걸린 시간

2. **Turnaround Time**

   실행 시간과 대기 시간을 모두 합한 시간. 작업이 완료 될 때까지 걸린 시간
