# Bit Masking

|              기능               |                코드                |                             의미                             |
| :-----------------------------: | :--------------------------------: | :----------------------------------------------------------: |
|             공집합              |                 0                  |                                                              |
|           꽉 찬 집합            |        int full = (1<<p)-1         |       (1<<20) : 1오른쪽에 0이 p개 => -1을 하면 1이 p개       |
|          p번 원소 추가          |         element \|= (1<<p)         | (1<<p) : 1오른쪽에 0이 p개 => p번 원소 나타냄<br />\|= : or연산을 통해 원소 추가 |
|        p번 원소 가져오기        |         element &  (1<<p)          | (1<<p) : 1오른쪽에 0이 p개 => p번 원소 나타냄<br />&= : and 연산을 통해 p번 원소가 1인지 0인지 확인 |
|      p번 원소 0으로 바꾸기      |         element &= ~(1<<p)         | ~(1<<p) : 0오른쪽에 1이 p개<br/>&= : and 연산을 통해 p번 원소를 0으로 바꿈 |
| p번 왼쪽 원소 모두 0으로 바꾸기 |       element &= ((1<<p)-1)        | (1<<p)-1 : 1이 p개인 원소<br/>&= : and 연산을 통해 p번 원소를 0으로 바꿈 |
|  p번 오른쪽 모두 0으로 바꾸기   |         element &= (-1<<p)         | (-1<<p) : 왼쪽은 모두 1이고 오른쪽에 0이 p개<br/>* -1은 모든 원소가 1 |
|     p번 원소 원하는 값 넣기     | element &= ~(1<<p)\|((val?1:0)<<p) | p번 원소 0으로 초기화 해준 후 => <br/>boolean val 입력을 받은 후 <br/>(val?1:0) : val이 true일 때 1, false일 때 0 반환<br/>p번 인덱스가 val에 해당하는 값으로 바뀜 |
|    원소 중 1인 것 개수 출력     |     Integer.bitCount(element)      |                                                              |

# Bit Masking 

{0, 1, 2, 3, 4}

몇가지 요소를 뽑아 어떤 요소를 선택했는지 표현

{1, 2, 3, 4}, {1, 2, 4}, {2, 4}, {1}, ...

Integer 형으로 인덱스 활용이 가능하면, boolean 배열을 통해서 구현 가능

```java
int[] array1 = {1, 1, 1, 1, 0};
int[] array2 = {1, 1, 0, 1, 0};
int[] array3 = {1, 0, 1, 0, 0};
```

위와 같은 표현은 메모리를 차지 많이하고 오버헤드 증가

```
{0, 1, 2, 3, 4} => 11111 => (2^4*1)+(2^3*1)+(2^2*1)+(2^1*1)+(2^0*1) = 31
{1, 2, 3, 4} => 11110 => (2^4*1)+(2^3*1)+(2^2*1)+(2^1*1) = 30
{1, 2, 4} => 10110 => (2^4*1)+(2^2*1)+(2^1*1) = 22
{2, 4} => 10100 => (2^4*1)+(2^2*1) = 20
{1} => 00010 => (2^1*1) => 2
```

##### AND연산(&)

대응하는 비트가 모두 1일 때 1 반환

```
1010 & 1111 = 1010
```

##### OR연산(|)

대응하는 두 비트가 모두 1 또는 하나라도 1일 때 1 반환

```
1010 | 1111 = 1111
```

##### XOR연산(^)

대응하는 두 비트가 서로 다르면 1 반환

```
1010 ^ 1111 = 0101
```

##### NOT연산(~)

비트의 값을 반전해서 반환

```
~1010 = 0101
```

##### Shift연산(>>, <<)

왼쪽 또는 오른쪽으로 비트 옮김

```
00001010 << 2 = 101000
00001010 >> 2 = 000010
```

왼쪽 시프트: A*2^B 의미

오른쪽 시프트: A/2^B 의미

0001 => 0010 => 0100 => 1000 => 1, 2, 4, 8

1000 => 0100 => 0010 => 0001 => 8, 4, 2, 1

##### 1010로 표현할 때, i번째 비트 값을 1로 변경하는 방법?

i = 2일 때 => 1110이 되어야 함

```
1010 | 1 << 2
1010 | 0100
```

##### 1010로 표현할 때, i번째 비트 값을 0으로 변경하는 방법?

```
1110 & ~1 << 2
1110 & 1011
```

##### i번째 비트 값을 아는 방법

```
A & (1<<i)
2번째 비트 => 1010 & (1<<2) => 1010 & 0100 => 0
3번째 비트 => 1010 & (1<<3) => 1010 & 1000 => 1000
```

# 외판원순회 문제 풀이
![solve](https://github.com/kimmy01/Today.I.Learned/blob/main/images/boj2098_1.jpg)
