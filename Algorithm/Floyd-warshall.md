# 플로이드 와샬

모든 쌍의 경로 존재 여부 + 모든 쌍의 최단 경로를 찾아내는 DP 알고리즘

시간 복잡도 : O(N^3)

1. 아이디어 떠올리기

   **그래프에 3개의 정점이 있는 경우**

   <img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC1.jpg" width="300px">

   정점 i에서 정점 j까지 최단 경로를 찾으려면 2가지 경로 존재

   - 정점 i => 정점 j
   - 정점 i =>  정점 1 => 정점 j

   2가지 경로 중 짧은 경로 선택

   **정점 1로부터 시작해서, 정점1과 2, 그다음엔 정점 1, 2, 3으로 하나씩 추가, 마지막에는 정점 1~N까지 모든 정점을 경유 할 수 있는 정점들로 고려하고, 모든 쌍의 최단 경로의 거리 계산**

2. DP 접근

   k != i, k != j, k = 0 인 경우, 정점 0은 그래프에 없음 => 어떠한 정점도 경유하지 않는 것 의미

   => 입력으로 주어지는 정점i => 정점j 가중치

   **모든 정점을 경유 가능한 정점들로 고려한 모든 쌍 i와 j의 최단 경로의 거리**를 찾는 방법!

```java
//dp[i][j] = 정점 i에서 정점 j로의 최소 비용
//relation[i][i] = 0
//relation[i][j] 입력 받은 값이 없으면 최댓값(123456789)
for(int k=1; k<=N; k++){
            for(int i=1; i<=N; i++){
                for(int j=1; j<=N; j++){
                    relation[i][j] = Math.min(relation[i][j], relation[i][k]+relation[k][j]);
                }
            }
        }
```



<img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%99%80%EC%83%AC2.jpg" width="700px">

### k = 1

```java
dp[4][2] = 2;
dp[4][3] = 0;
```

### k = 2

```java
dp[1][5] = 8;
dp[5][3] = -2;
```

### k = 3

```java
dp[2][4] = 2;
dp[1][5] = 4;
dp[5][1] = -1;
dp[2][1] = 2;
dp[2][5] = 3;
dp[5][4] = -1;
```

### k = 4

```java
dp[2][1] = 0;
dp[3][1] = -1;
dp[5][1] = -3;
```

### k = 5

```java
dp[1][2] = 1;
dp[3][2] = -1;
dp[4][2] = -1;
```

#### 최종

```java
{0, 1, 2, 3, 4}
{0, 0, 1, 2, 3}
{-1, -1, 0, 1, 2}
{-2, -1, 0, 0, 2}
{-3, -3, -2, -1, 0}
```

