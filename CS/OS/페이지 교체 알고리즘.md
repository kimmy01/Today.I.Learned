# 페이지 교체 알고리즘

가상 메모리는 페이지 **요구 페이징 기법**을 통해 필요한 페이지만 메모리에 적재, 사용하지 않는 부분은 그대로 둠

필요한 페이지만 올려도 메모리는 결국 가득 차고, 올라온 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음

메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 `out` 하고 해당 공간에 현재 필요한 페이지는 `in` 시켜야 함 => 어떤 페이지를 `out` 시킬 지 정해야 하고, 여기서 `out` 되는 페이지는 `victim page`라고 함

수정되지 않는 페이지를 선택하는 것이 좋음 (수정되면 메인 메모리에서 내보낼 때, 하드디스크에서 또 수정 진행해야하기 때문에 시간이 오래 걸림)

#### Page Reference String

CPU는 논리 주소를 통해서 특정 주소를 반환함

메인 메모리에 올라온 주소들은 페이지 단위로 가져오기 때문에 페이지 번호가 연속되어 나타나면 페이지 결함이 발생하지 않음

CPU 주소 요구에 따라 페이지 결함이 일어나지 않는 부분은 생략해서 표시하는 방법 => `Paging Reference String`

1. **FIFO 알고리즘**

   <img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/fifo.jpg" width="500px">

   메모리에 먼저 올라온 페이지 먼저 내보냄

   초기화 코드에서 적절한 방법 (가장 간단한 방법)

   `초기화 코드` : 처음 프로세스 실행될 때 최초 초기화를 시키는 역할만 진행하고 다른 역할은 수행하지 않으므로 메인 메모리에서 빼도 괜찮음

2. **OPT 알고리즘**

   <img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/opt.jpg" width="500px">

   앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보냄

   동일한 페이지가 이후에 언제 나올 지 거리를 계산해서 제일 멀리 있는 페이지 먼저 내보냄

   FIFO에 비해 페이지 결함 횟수 많이 감소시킬 수 있음

   실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없어서 수행하기 어려움

3. **LRU 알고리즘**

   <img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/lru.jpg" width="500px">

   최근에 가장 사용하지 않은 페이지를 먼저 내보냄

   최근에 사용하지 않았다면 나중에도 사용되지 않을 것이라는 가정

   OPT : 미래 예측

   LRU : 과거 보고 판단, 실질적으로 사용 가능

   OPT 보다 페이지 결함이 더 일어날 수 있지만 실제로 사용할 수 있는 페이지 교체 알고리즘 중 가장 좋은 방법 중 한 가지

#### 페이지 교체 방식

1. **Global** 방식

   메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식

2. **Local** 방식

   메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

다중 프로그래밍 => 메인 메모리에 다양한 프로세스 동시에 올라와 있을 수 있음 => 다양한 프로세스의 페이지가 메모리에 존재

페이지 교체 시, 다양한 페이지 교체 알고리즘을 활용해서 `victim page` 를 선정하는데, 선정 기준을 Global로 하느냐, Local로 하느냐의 차이!

실제로는 전체 기준으로 페이지 교체하는 것이 더 효율적~

자기 프로세스 페이지에서만 교체하면 교체 해야 할 때 각각 모두 교체해야 해서 비효율적



