# InsertionSort  

- 오름차순 정렬
- 손 안의 카드를 정렬하는 방법과 비슷
    - 새로운 카드를 기존의 정렬된 카드 사이에 알맞는 위치에 삽입
    - 새로 삽입될 카드 수만큼 반복하면 전체 카드 정렬 가능
- 배열의 모든 요소를 **앞에서부터 차례대로 이미 정렬된 배열과 비교**하여 자신의 위치를 찾아 가서 삽입하는 방법

### 구체적인 개념

- 두 번째 자료부터 시작해서, 그 앞의 자료들과 비교하여 삽입할 위치를 지정 후, 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘
- 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째, 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 뒤 자료가 삽입될 위치를 찾는 것
- 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동

<img src="https://github.com/kimmy01/Today.I.Learned/blob/main/images/InsertionSort1.jpg" width="500px">

### 삽입정렬의 장점

- 안정적인 정렬 방법
- 레코드 수가 적을 때 알고리즘 자체가 매우 간단해서 다른 복잡한 정렬 방법보다 유리할 수 있음
- 대부분 레코드가 이미 정렬되어 있는 경우에 매우 효율적

### 삽입정렬의 단점

- 비교적 많은 레코드들의 이동 포함
- 레코드 수가 많고 크기가 클 경우에 적합하지 않음

### 삽입정렬의 시간복잡도

**Best** 

이동 없이 1번만 비교할 때

외부 루프: (n-1)번

T(n) = O(n)

**Worst**

비교 횟수: 외부 루프 안의 각 반복마다 i번 비교 수행

외부 루프: 

(n-1)+(n-2)+(n-3)+...+2+1 = n(n-1)/2 = O(n^2)  

교환 횟수: 외부 루프의 각 단계마다 (i+2)번 이동 발생

n(n-1)/2+2(n-1)=(n^2+3n-4)/2 = O(n^2)

T(n) = O(n^2)
